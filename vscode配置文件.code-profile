{"name":".","settings":"{\"settings\":\"{\\r\\n\\t\\\"files.associations\\\": {\\r\\n\\t\\t\\\"*.vue\\\": \\\"vue\\\",\\r\\n\\t\\t\\\"*.wpy\\\": \\\"vue\\\",\\r\\n\\t\\t\\\"*.wxml\\\": \\\"html\\\",\\r\\n\\t\\t\\\"*.wxss\\\": \\\"css\\\",\\r\\n\\t\\t\\\"*.md\\\": \\\"markdown\\\",\\r\\n\\t\\t\\\"*.tex\\\": \\\"tex\\\"\\r\\n\\t},\\r\\n\\t\\\"git.enableSmartCommit\\\": true,\\r\\n\\t\\\"git.autofetch\\\": true,\\r\\n\\t\\\"emmet.triggerExpansionOnTab\\\": true,\\r\\n\\t\\\"emmet.showAbbreviationSuggestions\\\": true,\\r\\n\\t\\\"emmet.showExpandedAbbreviation\\\": \\\"always\\\",\\r\\n\\t\\\"emmet.includeLanguages\\\": {\\r\\n\\t\\t\\\"vue-html\\\": \\\"html\\\",\\r\\n\\t\\t\\\"vue\\\": \\\"html\\\",\\r\\n\\t\\t\\\"wpy\\\": \\\"html\\\"\\r\\n\\t},\\r\\n\\t\\\"git.confirmSync\\\": false,\\r\\n\\t\\\"explorer.confirmDelete\\\": false,\\r\\n\\t\\\"editor.fontSize\\\": 22,\\r\\n\\t\\\"editor.wordWrap\\\": \\\"on\\\",\\r\\n\\t\\\"editor.detectIndentation\\\": false,\\r\\n\\t\\\"files.autoSave\\\": \\\"afterDelay\\\",\\r\\n\\t\\\"editor.rulers\\\": [],\\r\\n\\t// 在使用搜索功能时，将这些文件夹/文件排除在外\\r\\n\\t\\\"search.exclude\\\": {\\r\\n\\t\\t\\\"**/node_modules\\\": true,\\r\\n\\t\\t\\\"**/bower_components\\\": true,\\r\\n\\t\\t\\\"**/target\\\": true,\\r\\n\\t\\t\\\"**/logs\\\": true,\\r\\n\\t},\\r\\n\\t// 这些文件将不会显示在工作空间中\\r\\n\\t\\\"files.exclude\\\": {\\r\\n\\t\\t\\\"**/.git\\\": true,\\r\\n\\t\\t\\\"**/.svn\\\": true,\\r\\n\\t\\t\\\"**/.hg\\\": true,\\r\\n\\t\\t\\\"**/CVS\\\": true,\\r\\n\\t\\t\\\"**/.DS_Store\\\": true,\\r\\n\\t\\t\\\"**/*.js\\\": {\\r\\n\\t\\t\\t\\\"when\\\": \\\"$(basename).ts\\\" //ts编译后生成的js文件将不会显示在工作空中\\r\\n\\t\\t},\\r\\n\\t\\t\\\"**/node_modules\\\": true\\r\\n\\t},\\r\\n\\t// #让vue中的js按\\\"prettier\\\"格式进行格式化\\r\\n\\t\\\"vetur.format.defaultFormatter.html\\\": \\\"js-beautify-html\\\",\\r\\n\\t\\\"vetur.format.defaultFormatter.js\\\": \\\"vscode-typescript\\\",\\r\\n\\t\\\"vetur.format.defaultFormatterOptions\\\": {\\r\\n\\t\\t\\\"js-beautify-html\\\": {\\r\\n\\t\\t\\t// #vue组件中html代码格式化样式\\r\\n\\t\\t\\t\\\"wrap_attributes\\\": \\\"force-aligned\\\", //也可以设置为“auto”，效果会不一样\\r\\n\\t\\t\\t\\\"wrap_line_length\\\": 200,\\r\\n\\t\\t\\t\\\"end_with_newline\\\": false,\\r\\n\\t\\t\\t\\\"semi\\\": false,\\r\\n\\t\\t\\t\\\"singleQuote\\\": true\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\t\\\"security.workspace.trust.untrustedFiles\\\": \\\"open\\\",\\r\\n\\t\\\"[cpp]\\\": {\\r\\n\\t\\t\\\"editor.wordBasedSuggestions\\\": \\\"off\\\",\\r\\n\\t\\t\\\"editor.suggest.insertMode\\\": \\\"replace\\\",\\r\\n\\t\\t\\\"editor.semanticHighlighting.enabled\\\": true,\\r\\n\\t\\t\\\"editor.defaultFormatter\\\": \\\"ms-vscode.cpptools\\\"\\r\\n\\t},\\r\\n\\t\\\"C_Cpp.legacyCompilerArgsBehavior\\\": true,\\r\\n\\t\\\"editor.insertSpaces\\\": false,\\r\\n\\t\\\"code-runner.runInTerminal\\\": true,\\r\\n\\t\\\"terminal.integrated.enableMultiLinePasteWarning\\\": false,\\r\\n\\t\\\"workbench.colorTheme\\\": \\\"Visual Studio 2017 Light - C++\\\",\\r\\n\\t\\\"editor.maxTokenizationLineLength\\\": 1e+36,\\r\\n\\t\\\"files.autoSaveDelay\\\": 2000,\\r\\n\\t\\\"cph.general.defaultLanguage\\\": \\\"cpp\\\",\\r\\n\\t\\\"cph.general.useShortCodeForcesName\\\": true,\\r\\n\\t\\\"cph.general.timeOut\\\": 2000,\\r\\n\\t\\\"settingsSync.keybindingsPerPlatform\\\": false,\\r\\n\\t\\\"editor.largeFileOptimizations\\\": false,\\r\\n\\t\\\"[markdown]\\\": {\\r\\n\\t\\t\\\"editor.defaultFormatter\\\": \\\"yzhang.markdown-all-in-one\\\"\\r\\n\\t},\\r\\n\\t\\\"luogu.defaultLanguage\\\": \\\"C++17\\\",\\r\\n\\t\\\"luogu.defaultWaitingTime\\\": 6000,\\r\\n\\t\\\"luogu.effectiveDuration\\\": -1,\\r\\n\\t\\\"[html]\\\": {\\r\\n\\t\\t\\\"editor.suggest.insertMode\\\": \\\"replace\\\",\\r\\n\\t\\t\\\"editor.formatOnType\\\": true\\r\\n\\t},\\r\\n\\t\\\"editor.minimap.showSlider\\\": \\\"always\\\",\\r\\n\\t\\\"markdownlint.focusMode\\\": true,\\r\\n\\t\\\"cmake.showOptionsMovedNotification\\\": false,\\r\\n\\t\\\"markdown.preview.openMarkdownLinks\\\": \\\"inPreview\\\",\\r\\n\\t\\\"markdown.preview.scrollEditorWithPreview\\\": true,\\r\\n\\t\\\"markdown.preview.doubleClickToSwitchToEditor\\\": true,\\r\\n\\t\\\"code-runner.executorMap\\\": {\\r\\n\\t\\t\\\"javascript\\\": \\\"node\\\",\\r\\n\\t\\t\\\"java\\\": \\\"cd $dir && javac $fileName && java $fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"c\\\": \\\"cd $dir && gcc $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"zig\\\": \\\"zig run\\\",\\r\\n\\t\\t\\\"cpp\\\": \\\"cd $dir && g++ -Wall -O2 $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"objective-c\\\": \\\"cd $dir && gcc -framework Cocoa $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"php\\\": \\\"php\\\",\\r\\n\\t\\t\\\"python\\\": \\\"python -u\\\",\\r\\n\\t\\t\\\"perl\\\": \\\"perl\\\",\\r\\n\\t\\t\\\"perl6\\\": \\\"perl6\\\",\\r\\n\\t\\t\\\"ruby\\\": \\\"ruby\\\",\\r\\n\\t\\t\\\"go\\\": \\\"go run\\\",\\r\\n\\t\\t\\\"lua\\\": \\\"lua\\\",\\r\\n\\t\\t\\\"groovy\\\": \\\"groovy\\\",\\r\\n\\t\\t\\\"powershell\\\": \\\"powershell -ExecutionPolicy ByPass -File\\\",\\r\\n\\t\\t\\\"bat\\\": \\\"cmd /c\\\",\\r\\n\\t\\t\\\"shellscript\\\": \\\"bash\\\",\\r\\n\\t\\t\\\"fsharp\\\": \\\"fsi\\\",\\r\\n\\t\\t\\\"csharp\\\": \\\"scriptcs\\\",\\r\\n\\t\\t\\\"vbscript\\\": \\\"cscript //Nologo\\\",\\r\\n\\t\\t\\\"typescript\\\": \\\"ts-node\\\",\\r\\n\\t\\t\\\"coffeescript\\\": \\\"coffee\\\",\\r\\n\\t\\t\\\"scala\\\": \\\"scala\\\",\\r\\n\\t\\t\\\"swift\\\": \\\"swift\\\",\\r\\n\\t\\t\\\"julia\\\": \\\"julia\\\",\\r\\n\\t\\t\\\"crystal\\\": \\\"crystal\\\",\\r\\n\\t\\t\\\"ocaml\\\": \\\"ocaml\\\",\\r\\n\\t\\t\\\"r\\\": \\\"Rscript\\\",\\r\\n\\t\\t\\\"applescript\\\": \\\"osascript\\\",\\r\\n\\t\\t\\\"clojure\\\": \\\"lein exec\\\",\\r\\n\\t\\t\\\"haxe\\\": \\\"haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"rust\\\": \\\"cd $dir && rustc $fileName && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"racket\\\": \\\"racket\\\",\\r\\n\\t\\t\\\"scheme\\\": \\\"csi -script\\\",\\r\\n\\t\\t\\\"ahk\\\": \\\"autohotkey\\\",\\r\\n\\t\\t\\\"autoit\\\": \\\"autoit3\\\",\\r\\n\\t\\t\\\"dart\\\": \\\"dart\\\",\\r\\n\\t\\t\\\"pascal\\\": \\\"cd $dir && fpc $fileName && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"d\\\": \\\"cd $dir && dmd $fileName && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"haskell\\\": \\\"runghc\\\",\\r\\n\\t\\t\\\"nim\\\": \\\"nim compile --verbosity:0 --hints:off --run\\\",\\r\\n\\t\\t\\\"lisp\\\": \\\"sbcl --script\\\",\\r\\n\\t\\t\\\"kit\\\": \\\"kitc --run\\\",\\r\\n\\t\\t\\\"v\\\": \\\"v run\\\",\\r\\n\\t\\t\\\"sass\\\": \\\"sass --style expanded\\\",\\r\\n\\t\\t\\\"scss\\\": \\\"scss --style expanded\\\",\\r\\n\\t\\t\\\"less\\\": \\\"cd $dir && lessc $fileName $fileNameWithoutExt.css\\\",\\r\\n\\t\\t\\\"FortranFreeForm\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"fortran-modern\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"fortran_fixed-form\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"fortran\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n\\t\\t\\\"sml\\\": \\\"cd $dir && sml $fileName\\\",\\r\\n\\t\\t\\\"mojo\\\": \\\"mojo run\\\"\\r\\n\\t},\\r\\n\\t\\\"editor.stickyScroll.enabled\\\": false,\\r\\n\\t\\\"chatgpt.lang\\\": \\\"cn\\\",\\r\\n\\t\\\"chatgpt.model\\\": \\\"gpt-3.5-turbo\\\",\\r\\n\\t\\\"editor.unicodeHighlight.ambiguousCharacters\\\": false,\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.beforeOpenBrace.function\\\": \\\"sameLine\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.beforeOpenBrace.block\\\": \\\"sameLine\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.beforeOpenBrace.namespace\\\": \\\"sameLine\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.beforeOpenBrace.type\\\": \\\"sameLine\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.beforeOpenBrace.lambda\\\": \\\"sameLine\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.closeBraceSameLine.emptyFunction\\\": true,\\r\\n\\t\\\"C_Cpp.vcFormat.newLine.closeBraceSameLine.emptyType\\\": true,\\r\\n\\t\\\"C_Cpp.vcFormat.space.afterCastCloseParenthesis\\\": true,\\r\\n\\t\\\"C_Cpp.vcFormat.indent.gotoLabels\\\": \\\"leftmostColumn\\\",\\r\\n\\t\\\"C_Cpp.vcFormat.space.afterComma\\\": false,\\r\\n\\t\\\"C_Cpp.clang_format_style\\\": \\\"{BasedOnStyle: Google, IndentWidth: 2}\\\",\\r\\n\\t\\\"eslint.codeActionsOnSave.rules\\\": null,\\r\\n\\t// \\\"editor.formatOnSave\\\": true,\\r\\n\\t// #每次保存的时候将代码按eslint格式进行修复\\r\\n\\t\\\"eslint.autoFixOnSave\\\": true,\\r\\n\\t// 添加 vue 支持\\r\\n\\t\\\"eslint.validate\\\": [\\r\\n\\t\\t\\\"javascript\\\",\\r\\n\\t\\t\\\"javascriptreact\\\",\\r\\n\\t\\t{\\r\\n\\t\\t\\t\\\"language\\\": \\\"vue\\\",\\r\\n\\t\\t\\t\\\"autoFix\\\": true\\r\\n\\t\\t}\\r\\n\\t],\\r\\n\\t//\\t#让prettier使用eslint的代码格式进行校验\\r\\n\\t\\\"prettier.eslintIntegration\\\": true,\\r\\n\\t//\\t#去掉代码结尾的分号\\r\\n\\t\\\"prettier.semi\\\": false,\\r\\n\\t//\\t#使用带引号替代双引号\\r\\n\\t\\\"prettier.singleQuote\\\": true,\\r\\n\\t//\\t#让函数(名)和后面的括号之间加个空格\\r\\n\\t\\\"javascript.format.insertSpaceBeforeFunctionParenthesis\\\": true,\\r\\n\\t// #让vue中的js按编辑器自带的ts格式进行格式化\\r\\n\\t\\\"explorer.confirmDragAndDrop\\\": false,\\r\\n\\t// \\\"editor.renderControlCharacters\\\": true,\\r\\n\\t// \\\"editor.renderWhitespace\\\": \\\"all\\\",\\r\\n\\t\\\"editor.codeActionsOnSave\\\": {\\r\\n\\t\\t\\\"source.fixAll.eslint\\\": \\\"explicit\\\"\\r\\n\\t}\\r\\n}\"}","tasks":"{\"tasks\":\"{\\n    \\\"files.associations\\\": {\\n    \\\"*.vue\\\": \\\"vue\\\",\\n    \\\"*.wpy\\\": \\\"vue\\\",\\n    \\\"*.wxml\\\": \\\"html\\\",\\n    \\\"*.wxss\\\": \\\"css\\\"\\n    },\\n    \\\"terminal.integrated.shell.windows\\\": \\\"C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\cmd.exe\\\",\\n    \\\"git.enableSmartCommit\\\": true,\\n    \\\"git.autofetch\\\": true,\\n    \\\"emmet.triggerExpansionOnTab\\\": true,\\n    \\\"emmet.showAbbreviationSuggestions\\\": true,\\n    \\\"emmet.showExpandedAbbreviation\\\": \\\"always\\\",\\n    \\\"emmet.includeLanguages\\\": {\\n    \\\"vue-html\\\": \\\"html\\\",\\n    \\\"vue\\\": \\\"html\\\",\\n    \\\"wpy\\\": \\\"html\\\"\\n    },\\n    //主题颜色 \\n    //\\\"workbench.colorTheme\\\": \\\"Monokai\\\",\\n    \\\"git.confirmSync\\\": false,\\n    \\\"explorer.confirmDelete\\\": false,\\n    \\\"editor.fontSize\\\": 14,\\n    \\\"window.zoomLevel\\\": 1,\\n    \\\"editor.wordWrap\\\": \\\"on\\\",\\n    \\\"editor.detectIndentation\\\": false,\\n    // 重新设定tabsize\\n    \\\"editor.tabSize\\\": 2,\\n    //失去焦点后自动保存\\n    \\\"files.autoSave\\\": \\\"onFocusChange\\\",\\n    // #值设置为true时，每次保存的时候自动格式化；\\n    \\\"editor.formatOnSave\\\": false,\\n     //每120行就显示一条线\\n    \\\"editor.rulers\\\": [\\n    ],\\n    // 在使用搜索功能时，将这些文件夹/文件排除在外\\n    \\\"search.exclude\\\": {\\n        \\\"**/node_modules\\\": true,\\n        \\\"**/bower_components\\\": true,\\n        \\\"**/target\\\": true,\\n        \\\"**/logs\\\": true,\\n    }, \\n    // 这些文件将不会显示在工作空间中\\n    \\\"files.exclude\\\": {\\n        \\\"**/.git\\\": true,\\n        \\\"**/.svn\\\": true,\\n        \\\"**/.hg\\\": true,\\n        \\\"**/CVS\\\": true,\\n        \\\"**/.DS_Store\\\": true,\\n        \\\"**/*.js\\\": {\\n            \\\"when\\\": \\\"$(basename).ts\\\" //ts编译后生成的js文件将不会显示在工作空中\\n        },\\n        \\\"**/node_modules\\\": true\\n    }, \\n    // #让vue中的js按\\\"prettier\\\"格式进行格式化\\n    \\\"vetur.format.defaultFormatter.html\\\": \\\"js-beautify-html\\\",\\n    \\\"vetur.format.defaultFormatter.js\\\": \\\"prettier\\\",\\n    \\\"vetur.format.defaultFormatterOptions\\\": {\\n        \\\"js-beautify-html\\\": {\\n            // #vue组件中html代码格式化样式\\n            \\\"wrap_attributes\\\": \\\"force-aligned\\\", //也可以设置为“auto”，效果会不一样\\n            \\\"wrap_line_length\\\": 200,\\n            \\\"end_with_newline\\\": false,\\n            \\\"semi\\\": false,\\n            \\\"singleQuote\\\": true\\n        },\\n        \\\"prettier\\\": {\\n            \\\"semi\\\": false,\\n            \\\"singleQuote\\\": true\\n        }\\n    }\\n  }\"}","snippets":"{\"snippets\":{\"cpp.json\":\"{\\r\\n    \\\"#include\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"#include\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"#include<bits/stdc++.h>\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"int main()\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n            \\\"    \\\",\\r\\n            \\\"    return 0;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"fast IO\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"fast IO\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"#include<bits/stdc++.h>\\\",\\r\\n\\t\\t\\t\\\"namespace fast_IO\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    #define Getchar() p1==p2 and (p2=(p1=Inf)+fread(Inf,1,1<<21,stdin),p1==p2)?EOF:*p1++\\\",\\r\\n\\t\\t\\t\\\"    #define Putchar(c) p3==p4 and (fwrite(Ouf,1,1<<21,stdout),p3=Ouf),*p3++=c\\\",\\r\\n\\t\\t\\t\\\"    char Inf[1<<21],Ouf[1<<21],*p1,*p2,*p3=Ouf,*p4=Ouf+(1<<21);\\\",\\r\\n\\t\\t\\t\\\"    const long long pow10[20]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,10000000000000000,100000000000000000,1000000000000000000};\\\",\\r\\n\\t\\t\\t\\\"    const long double pow01[20]={1,0.1,0.01,0.001,0.0001,0.00001,0.000001,0.0000001,0.00000001,0.000000001,0.0000000001,0.00000000001,0.000000000001,0.0000000000001,0.00000000000001,0.000000000000001,0.0000000000000001};\\\",\\r\\n\\t\\t\\t\\\"    const long double my_round[20]={5,0.5,0.05,0.005,0.0005,0.00005,0.000005,0.0000005,0.00000005,0.000000005,0.0000000005,0.00000000005,0.000000000005,0.0000000000005,0.00000000000005,0.000000000000005,0.0000000000000005};\\\",\\r\\n\\t\\t\\t\\\"    inline void read(int &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(int x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(x<0) Putchar(45),x=-x;\\\",\\r\\n\\t\\t\\t\\\"        if(x>=10) write(x/10),x%=10;\\\",\\r\\n\\t\\t\\t\\\"        Putchar(x^48);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(short &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(short x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(x<0) Putchar(45),x=-x;\\\",\\r\\n\\t\\t\\t\\\"        if(x>=10) write(x/10),x%=10;\\\",\\r\\n\\t\\t\\t\\\"        Putchar(x^48);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(long long &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(long long x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(x<0) Putchar(45),x=-x;\\\",\\r\\n\\t\\t\\t\\\"        if(x>=10) write(x/10),x%=10;\\\",\\r\\n\\t\\t\\t\\\"        Putchar(x^48);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(__int128 &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(__int128 x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(x<0) Putchar(45),x=-x;\\\",\\r\\n\\t\\t\\t\\\"        if(x>=10) write(x/10),x%=10;\\\",\\r\\n\\t\\t\\t\\\"        Putchar(x^48);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n            \\\"    inline bool inrange(const char &ch)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(ch>=33 and ch<=126) return true;\\\",\\r\\n\\t\\t\\t\\\"        return false;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(std::string &st,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        st.clear();\\\",\\r\\n\\t\\t\\t\\\"        while(!inrange(c)) c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        while(inrange(c)) st+=c,c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(std::string st)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=0;i<st.size();i++) Putchar(st[i]);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(char &ch)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        ch=Getchar();\\\",\\r\\n\\t\\t\\t\\\"        while(!inrange(ch)) ch=Getchar();\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(const char &ch)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Putchar(ch);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(double &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57 or c==46)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(c>=48 and c<=57) x=x*10+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"            else\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                int t=1;c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"                while(c>=48 and c<=57) x+=pow01[t]*(c^48),t++,c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"                break;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(double x,int fix=6)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        x+=x>0?my_round[fix+1]:-my_round[fix+1],write((__int128)x),x=x>0?x:-x,x-=(__int128)x;\\\",\\r\\n\\t\\t\\t\\\"        if(fix)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            Putchar(46);\\\",\\r\\n\\t\\t\\t\\\"            while(fix--) x*=10,Putchar(((int)x)^48),x-=(int)x;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void read(long double &x,char c=Getchar())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        x=0;\\\",\\r\\n\\t\\t\\t\\\"        bool f=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c<48 or c>57) c=Getchar(),f&=c!=45;\\\",\\r\\n\\t\\t\\t\\\"        while(c>=48 and c<=57 or c==46)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(c>=48 and c<=57) x=x*10+(c^48),c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"            else\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                int t=1;c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"                while(c>=48 and c<=57) x+=pow01[t]*(c^48),t++,c=Getchar();\\\",\\r\\n\\t\\t\\t\\\"                break;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        x=f?x:-x;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void write(long double x,int fix=6)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        x+=x>0?my_round[fix+1]:-my_round[fix+1],write((__int128)x),x=x>0?x:-x,x-=(__int128)x;\\\",\\r\\n\\t\\t\\t\\\"        if(fix)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            Putchar(46);\\\",\\r\\n\\t\\t\\t\\\"            while(fix--) x*=10,Putchar(((int)x)^48),x-=(int)x;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    class fastin\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"    public:\\\",\\r\\n\\t\\t\\t\\\"        template<typename T>\\\",\\r\\n\\t\\t\\t\\\"        inline fastin &operator>>(T &x)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            read(x);\\\",\\r\\n\\t\\t\\t\\\"            return *this;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    };\\\",\\r\\n\\t\\t\\t\\\"    class fastout\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"    public:\\\",\\r\\n\\t\\t\\t\\\"        template<typename T>\\\",\\r\\n\\t\\t\\t\\\"        inline fastout &operator<<(T x)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            write(x);\\\",\\r\\n\\t\\t\\t\\\"            return *this;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    };\\\",\\r\\n\\t\\t\\t\\\"    fastin in;\\\",\\r\\n\\t\\t\\t\\\"    fastout out;\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"using namespace fast_IO;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n            \\\"int main()\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n            \\\"    \\\",\\r\\n\\t\\t\\t\\\"    fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);\\\",\\r\\n            \\\"    return 0;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"fast op\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"fast op\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"#pragma GCC optimize(\\\\\\\"Ofast\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"inline\\\\\\\")\\\",\\r\\n            \\\"#pragma GCC optimize(\\\\\\\"-falign-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-falign-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-falign-labels\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-falign-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fcaller-saves\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fcrossjumping\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fcse-follow-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fdelete-null-pointer-checks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fdevirtualize\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fexpensive-optimizations\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-ffast-math\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fgcse\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fgcse-lm\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fhoist-adjacent-loads\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-finline\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-finline\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fipa-sra\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"no-stack-protector\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-foptimize-sibling-calls\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fpartial-inlining\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fpeephole2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-freorder-blocks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-freorder-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-frerun-cse-after-loop\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fsched-interblock\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fsched-spec\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fschedule-insns\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fschedule-insns2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fstrict-aliasing\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-fthread-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-ftree-pre\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-ftree-switch-conversion\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-ftree-tail-merge\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-ftree-vrp\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC optimize(\\\\\\\"-funroll-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"abm\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"avx\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"mmx\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"popcnt\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"sse\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"sse2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"sse3\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"sse4\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"ssse3\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma GCC target(\\\\\\\"tune=native\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-small-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-finline-small-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"unroll-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fwhole-program\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fcse-skip-blocks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-funsafe-loop-optimizations\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-functions-called-once\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fstrict-overflow\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"Ofast\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline\\\\\\\")\\\",\\r\\n            \\\"#pragma G++ optimize(\\\\\\\"-falign-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-falign-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-falign-labels\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-falign-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fcaller-saves\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fcrossjumping\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fcse-follow-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fdelete-null-pointer-checks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fdevirtualize\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fexpensive-optimizations\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-ffast-math\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fgcse\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fgcse-lm\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fhoist-adjacent-loads\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-finline\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-finline\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fipa-sra\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"no-stack-protector\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-foptimize-sibling-calls\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fpartial-inlining\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fpeephole2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-freorder-blocks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-freorder-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-frerun-cse-after-loop\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fsched-interblock\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fsched-spec\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fschedule-insns\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fschedule-insns2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fstrict-aliasing\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fthread-jumps\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-ftree-pre\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-ftree-switch-conversion\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-ftree-tail-merge\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-ftree-vrp\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-funroll-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"abm\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"avx\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"mmx\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"popcnt\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"sse\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"sse2\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"sse3\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"sse4\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"ssse3\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ target(\\\\\\\"tune=native\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-small-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-finline-small-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"unroll-loops\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fwhole-program\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fcse-skip-blocks\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-funsafe-loop-optimizations\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-functions-called-once\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"inline-functions\\\\\\\")\\\",\\r\\n\\t\\t\\t\\\"#pragma G++ optimize(\\\\\\\"-fstrict-overflow\\\\\\\")\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"int_ksm\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"int_ksm\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline int ksm(int a,int b)\\\",\\r\\n            \\\"{\\\",\\r\\n            \\\"    int ret=1;\\\",\\r\\n\\t\\t\\t\\\"    while(b)\\\",\\r\\n            \\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(b&1) ret=ret*a%p,b--;\\\",\\r\\n            \\\"        a=a*a%p,b>>=1;\\\",\\r\\n            \\\"    }\\\",\\r\\n\\t\\t\\t\\\"    return ret;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"fwrite\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"fwrite\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"fileIO\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"fileIO\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline void fileIO(std::string filename=\\\\\\\"example\\\\\\\")\\\",\\r\\n            \\\"{\\\",\\r\\n            \\\"    std::string I=filename+\\\\\\\".in\\\\\\\",O=filename+\\\\\\\".out\\\\\\\";\\\",\\r\\n\\t\\t\\t\\\"    freopen(I.c_str(),\\\\\\\"r\\\\\\\",stdin);\\\",\\r\\n            \\\"    freopen(O.c_str(),\\\\\\\"w\\\\\\\",stdout);\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"long_ksm\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"long_ksm\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline long long ksm(long long a,long long b)\\\",\\r\\n            \\\"{\\\",\\r\\n            \\\"    long long ret=1;\\\",\\r\\n\\t\\t\\t\\\"    while(b)\\\",\\r\\n            \\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(b&1) ret=ret*a%p,b--;\\\",\\r\\n            \\\"        a=a*a%p,b>>=1;\\\",\\r\\n            \\\"    }\\\",\\r\\n\\t\\t\\t\\\"    return ret;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"int_gcd\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"int_gcd\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline int gcd(int a,int b)\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    return b?gcd(b,a%b):a;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"long_gcd\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"long_gcd\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline long long gcd(long long a,long long b)\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    return b?gcd(b,a%b):a;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"dijkstra\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"dijkstra\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"std::priority_queue< std::pair<int,int> > q;\\\",\\r\\n            \\\"inline void dijkstra(int s)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    memset(dis,0x3f,sizeof(dis)),dis[s]=0,q.push(std::make_pair(0,s));\\\",\\r\\n\\t\\t\\t\\\"    while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        pos=q.top().second,q.pop();\\\",\\r\\n\\t\\t\\t\\\"        if(v[pos]) continue;\\\",\\r\\n\\t\\t\\t\\\"        v[pos]=1;\\\",\\r\\n\\t\\t\\t\\\"        for(edge *i=head[pos];i!=nullptr;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            x=i->to,y=i->cost;\\\",\\r\\n\\t\\t\\t\\\"            if(dis[x]>dis[pos]+y) dis[x]=dis[pos]+y,q.push(std::make_pair(-dis[x],x));\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"tarjan\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"tarjan\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n            \\\"inline void tarjan(const int pos) // dfn[N],low[N],times,fl[N],belong[N],tot,tp\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    dfn[pos]=low[pos]=++times,v.push_back(pos),fl[pos]=1;\\\",\\r\\n\\t\\t\\t\\\"    for(edge *i=head[pos];i;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"        if(!dfn[i->to]) tarjan(i->to),low[pos]=std::min(low[pos],low[i->to]);\\\",\\r\\n\\t\\t\\t\\\"        else if(fl[i->to]) low[pos]=std::min(low[pos],dfn[i->to]);\\\",\\r\\n\\t\\t\\t\\\"    if(dfn[pos]==low[pos])\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        tot++,tp=-1;\\\",\\r\\n\\t\\t\\t\\\"        while(tp!=pos) tp=v.back(),v.pop_back(),belong[tp]=tot,fl[tp]=0;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"euler_sieve\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"euler_sieve\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n            \\\"inline void euler() // phi[N],pre[N],prim[N],vis[N],cnt\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    phi[1]=pre[1]=1;\\\",\\r\\n\\t\\t\\t\\\"    for(int i=2;i<=n;i++)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(!vis[i]) prim[++cnt]=i,phi[i]=i-1,vis[i]=1;\\\",\\r\\n\\t\\t\\t\\\"        for(int j=1;j<=cnt && prim[j]*i<=n;j++)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            vis[i*prim[j]]=1,phi[i*prim[j]]=phi[i]*(i%prim[j]?prim[j]-1:prim[j]);\\\",\\r\\n\\t\\t\\t\\\"            if(i%prim[j]==0) break;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        pre[i]=pre[i-1]+phi[i];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"euler_fun\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"euler_fun\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n            \\\"inline int euler(int n) // prim[N]\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    int ans=n;\\\",\\r\\n\\t\\t\\t\\\"    for(int i=1;i<=cnt && prim[i]*prim[i]<=n;i++)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(n%prim[i]) continue;\\\",\\r\\n\\t\\t\\t\\\"        ans=ans/prim[i]*(prim[i]-1);\\\",\\r\\n\\t\\t\\t\\\"        while(n%prim[i]==0) n/=prim[i];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    if(n>1) ans=ans/n*(n-1);\\\",\\r\\n\\t\\t\\t\\\"    return ans;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"find\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"find\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline int find(int x)\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    if(x==fa[x]) return x;\\\",\\r\\n\\t\\t\\t\\\"    return fa[x]=find(fa[x]);\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"heavy_cut\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"heavy_cut\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n            \\\"inline void dfs1(int pos,int fa,int depth,int maxi=-0x3f3f3f3f) // ,dep[N],f[N],siz[N],hvson[N]\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    dep[pos]=depth,f[pos]=fa,siz[pos]=1;\\\",\\r\\n\\t\\t\\t\\\"    for(edge *i=head[pos];i;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"        if(i->to!=fa)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            dfs1(i->to,pos,depth+1),siz[pos]+=siz[i->to];\\\",\\r\\n\\t\\t\\t\\\"            if(siz[i->to]>maxi) hvson[pos]=i->to,maxi=siz[i->to];\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"inline void dfs2(int pos,int Start) // ,id[N],tot,neww[N],w[N],start[N]\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    id[pos]=++tot,neww[tot]=w[pos],start[pos]=Start;\\\",\\r\\n\\t\\t\\t\\\"    if(hvson[pos])\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n            \\\"        dfs2(hvson[pos],Start);\\\",\\r\\n            \\\"        for(edge *i=head[pos];i;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"            if(i->to!=f[pos] && i->to!=hvson[pos]) dfs2(i->to,i->to);\\\",\\r\\n            \\\"    }\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"lca\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"lca\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"inline int lca(int x,int y)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n            \\\"    while(start[x]!=start[y])\\\",\\r\\n\\t\\t\\t\\\"        if(dep[start[x]]>=dep[start[y]]) x=f[start[x]];\\\",\\r\\n            \\\"        else y=f[start[y]];\\\",\\r\\n            \\\"    if(dep[x]>=dep[y]) return y;\\\",\\r\\n\\t\\t\\t\\\"    else return x;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"edge\\\":\\r\\n\\t{\\r\\n        \\\"prefix\\\": \\\"edge\\\",\\r\\n        \\\"body\\\":\\r\\n\\t\\t[\\r\\n            \\\"struct edge\\\",\\r\\n            \\\"{\\\",\\r\\n\\t\\t\\t\\\"    int to;\\\",\\r\\n\\t\\t\\t\\\"    edge *next;\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"edge *head[];\\\",\\r\\n\\t\\t\\t\\\"inline void add(const int x,const int y)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    edge *e=new edge;\\\",\\r\\n\\t\\t\\t\\\"    e->to=y,e->next=head[x],head[x]=e;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n    },\\r\\n\\t\\\"Treap\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"Treap\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"struct Treap_node\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    int val,w,cnt,siz;\\\",\\r\\n\\t\\t\\t\\\"    Treap_node *lc,*rc;\\\",\\r\\n\\t\\t\\t\\\"    Treap_node(int Val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        val=Val,w=rand(),cnt=siz=1,lc=rc=nullptr;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void pushup()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        siz=(lc==nullptr?0:lc->siz)+(rc==nullptr?0:rc->siz)+cnt;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"class Treap\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"private:\\\",\\r\\n\\t\\t\\t\\\"    Treap_node *root;\\\",\\r\\n\\t\\t\\t\\\"    inline int askrank(Treap_node *rt,int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(rt==nullptr) return 0;\\\",\\r\\n\\t\\t\\t\\\"        int left=rt->lc==nullptr?0:rt->lc->siz;\\\",\\r\\n\\t\\t\\t\\\"        if(val==rt->val) return left;\\\",\\r\\n\\t\\t\\t\\\"        else if(val<rt->val) return askrank(rt->lc,val);\\\",\\r\\n\\t\\t\\t\\\"        else return askrank(rt->rc,val)+left+rt->cnt;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int askval(Treap_node *rt,int pos)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(rt==nullptr) return 1e9;\\\",\\r\\n\\t\\t\\t\\\"        int left=rt->lc==nullptr?0:rt->lc->siz;\\\",\\r\\n\\t\\t\\t\\\"        if(pos<=left) return askval(rt->lc,pos);\\\",\\r\\n\\t\\t\\t\\\"        else if(pos<=left+rt->cnt) return rt->val;\\\",\\r\\n\\t\\t\\t\\\"        return askval(rt->rc,pos-left-rt->cnt);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline Treap_node *right(Treap_node *rt)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Treap_node *q=rt->lc;\\\",\\r\\n\\t\\t\\t\\\"        rt->lc=q->rc,q->rc=rt,rt->pushup(),q->pushup();\\\",\\r\\n\\t\\t\\t\\\"        return q;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline Treap_node *left(Treap_node *rt)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Treap_node *q=rt->rc;\\\",\\r\\n\\t\\t\\t\\\"        rt->rc=q->lc,q->lc=rt,rt->pushup(),q->pushup();\\\",\\r\\n\\t\\t\\t\\\"        return q;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline Treap_node *add(Treap_node *rt,int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Treap_node *ret=rt;\\\",\\r\\n\\t\\t\\t\\\"        if(rt==nullptr) ret=new Treap_node(val);\\\",\\r\\n\\t\\t\\t\\\"        else if(val==rt->val) rt->cnt++;\\\",\\r\\n\\t\\t\\t\\\"        else if(val<rt->val)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            rt->lc=add(rt->lc,val);\\\",\\r\\n\\t\\t\\t\\\"            if(rt->w<rt->lc->w) ret=right(rt);\\\",\\r\\n\\t\\t\\t\\\"        }else\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            rt->rc=add(rt->rc,val);\\\",\\r\\n\\t\\t\\t\\\"            if(rt->w<rt->rc->w) ret=left(rt);\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        ret->pushup();\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline Treap_node *del(Treap_node *rt,int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(rt==nullptr) return nullptr;\\\",\\r\\n\\t\\t\\t\\\"        if(val==rt->val)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(rt->cnt>1)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                rt->cnt--,rt->pushup();\\\",\\r\\n\\t\\t\\t\\\"                return rt;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"            if(rt->lc==nullptr && rt->rc==nullptr)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                delete rt;\\\",\\r\\n\\t\\t\\t\\\"                return nullptr;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"            Treap_node *ret=rt;\\\",\\r\\n\\t\\t\\t\\\"            if(rt->rc==nullptr || rt->lc!=nullptr && rt->lc->w>rt->rc->w)\\\",\\r\\n\\t\\t\\t\\\"                ret=right(rt),ret->rc=del(ret->rc,val);\\\",\\r\\n\\t\\t\\t\\\"            else ret=left(rt),ret->lc=del(ret->lc,val);\\\",\\r\\n\\t\\t\\t\\\"            if(ret!=nullptr) ret->pushup();\\\",\\r\\n\\t\\t\\t\\\"            return ret;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        val<rt->val?rt->lc=del(rt->lc,val):rt->rc=del(rt->rc,val);\\\",\\r\\n\\t\\t\\t\\\"        if(rt!=nullptr) rt->pushup();\\\",\\r\\n\\t\\t\\t\\\"        return rt;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"public:\\\",\\r\\n\\t\\t\\t\\\"    Treap()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        root=new Treap_node(-1e9),root->rc=new Treap_node(1e9),root->pushup();\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void add(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        root=add(root,val);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void del(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        root=del(root,val);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int askrank(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return askrank(root,val);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int askval(int rank)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return askval(root,rank+1);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int askpre(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Treap_node *rt=root;\\\",\\r\\n\\t\\t\\t\\\"        int ans=-1e9;\\\",\\r\\n\\t\\t\\t\\\"        while(rt!=nullptr)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(val==rt->val)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                if(rt->lc!=nullptr)\\\",\\r\\n\\t\\t\\t\\\"                {\\\",\\r\\n\\t\\t\\t\\\"                    rt=rt->lc;\\\",\\r\\n\\t\\t\\t\\\"                    while(rt->rc!=nullptr) rt=rt->rc;\\\",\\r\\n\\t\\t\\t\\\"                    ans=rt->val;\\\",\\r\\n\\t\\t\\t\\\"                }\\\",\\r\\n\\t\\t\\t\\\"                break;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"            if(rt->val<val && rt->val>ans) ans=rt->val;\\\",\\r\\n\\t\\t\\t\\\"            rt=val<rt->val?rt->lc:rt->rc;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        return ans;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int asknext(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        Treap_node *rt=root;\\\",\\r\\n\\t\\t\\t\\\"        int ans=1e9;\\\",\\r\\n\\t\\t\\t\\\"        while(rt!=nullptr)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(val==rt->val)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                if(rt->rc!=nullptr)\\\",\\r\\n\\t\\t\\t\\\"                {\\\",\\r\\n\\t\\t\\t\\\"                    rt=rt->rc;\\\",\\r\\n\\t\\t\\t\\\"                    while(rt->lc!=nullptr) rt=rt->lc;\\\",\\r\\n\\t\\t\\t\\\"                    ans=rt->val;\\\",\\r\\n\\t\\t\\t\\\"                }\\\",\\r\\n\\t\\t\\t\\\"                 break;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"            if(rt->val>val && rt->val<ans) ans=rt->val;\\\",\\r\\n\\t\\t\\t\\\"            rt=val<rt->val?rt->lc:rt->rc;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        return ans;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\"\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"fhq_treap\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"fhq_treap\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"template<typename T>\\\",\\r\\n\\t\\t\\t\\\"inline void swap(T &_x,T &_y)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    T tmp=_x;\\\",\\r\\n\\t\\t\\t\\\"    _x=_y,_y=tmp;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"struct fhq_node\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    int val,w,siz,lazy;\\\",\\r\\n\\t\\t\\t\\\"    fhq_node *lc,*rc;\\\",\\r\\n\\t\\t\\t\\\"    inline fhq_node(int val)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        this->val=val,w=rand(),siz=1,lazy=0,lc=rc=nullptr;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void pushup()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        siz=(lc==nullptr?0:lc->siz)+(rc==nullptr?0:rc->siz)+1;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void pushdown()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(lazy)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(lc!=nullptr) lc->lazy^=1,swap(lc->lc,lc->rc);\\\",\\r\\n\\t\\t\\t\\\"            if(rc!=nullptr) rc->lazy^=1,swap(rc->lc,rc->rc);\\\",\\r\\n\\t\\t\\t\\\"            lazy=0;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"class fhq_treap\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"private:\\\",\\r\\n\\t\\t\\t\\\"    fhq_node *root;\\\",\\r\\n\\t\\t\\t\\\"    inline fhq_node *merge(fhq_node *l,fhq_node *r)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(l==nullptr && r==nullptr) return nullptr;\\\",\\r\\n\\t\\t\\t\\\"        if(l==nullptr) return r;\\\",\\r\\n\\t\\t\\t\\\"        if(r==nullptr) return l;\\\",\\r\\n\\t\\t\\t\\\"        if(l->w<r->w)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            l->pushdown(),l->rc=merge(l->rc,r),l->pushup();\\\",\\r\\n\\t\\t\\t\\\"            return l;\\\",\\r\\n\\t\\t\\t\\\"        }else\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            r->pushdown(),r->lc=merge(l,r->lc),r->pushup();\\\",\\r\\n\\t\\t\\t\\\"            return r;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline std::pair<fhq_node *,fhq_node *> split_rank(fhq_node *rt,const int k)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        std::pair<fhq_node *,fhq_node *> ret;\\\",\\r\\n\\t\\t\\t\\\"        if(rt==nullptr) return std::make_pair(nullptr,nullptr);\\\",\\r\\n\\t\\t\\t\\\"        rt->pushdown();\\\",\\r\\n\\t\\t\\t\\\"        int left=rt->lc==nullptr?0:rt->lc->siz;\\\",\\r\\n\\t\\t\\t\\\"        if(k<=left) ret=split_rank(rt->lc,k),rt->lc=ret.second,rt->pushup(),ret.second=rt;\\\",\\r\\n\\t\\t\\t\\\"        else ret=split_rank(rt->rc,k-left-1),rt->rc=ret.first,rt->pushup(),ret.first=rt;\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"public:\\\",\\r\\n\\t\\t\\t\\\"    inline void overturn(const int L,const int R)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        std::pair<fhq_node *,fhq_node *> a,b;\\\",\\r\\n\\t\\t\\t\\\"        a=split_rank(root,R),b=split_rank(a.first,L-1);\\\",\\r\\n\\t\\t\\t\\\"        b.second->lazy^=1,swap(b.second->lc,b.second->rc);\\\",\\r\\n\\t\\t\\t\\\"        root=merge(merge(b.first,b.second),a.second);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\"\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"BIT\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"BIT\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"class BIT\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    #define N 100010\\\",\\r\\n\\t\\t\\t\\\"private:\\\",\\r\\n\\t\\t\\t\\\"    int c[N]; // 一定要记得改！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\\\",\\r\\n\\t\\t\\t\\\"    inline int lowbit(const int x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return x&(-x);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"public:\\\",\\r\\n\\t\\t\\t\\\"    inline void fix(int pos,int x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        while(pos<=n) c[pos]+=x,pos+=lowbit(pos);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int ask(int pos)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        int ret=0;\\\",\\r\\n\\t\\t\\t\\\"        while(pos) ret+=c[pos],pos-=lowbit(pos);\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\"\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"high_accuracy\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"high_accuracy\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"class high_accuracy\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"private:\\\",\\r\\n\\t\\t\\t\\\"    int len,a[300];\\\",\\r\\n\\t\\t\\t\\\"public:\\\",\\r\\n\\t\\t\\t\\\"    inline int &operator[](const int x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return a[x];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline int size()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return len;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    high_accuracy()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        len=0,memset(a,0,sizeof(a));\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void init(__int128 x)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        len=0,memset(a,0,sizeof(a));\\\",\\r\\n\\t\\t\\t\\\"        if(x==0) len=1;\\\",\\r\\n\\t\\t\\t\\\"        while(x) a[++len]=x%10,x/=10;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void deal(int l)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=l;i++) a[i+1]+=a[i]/10,a[i]%=10;\\\",\\r\\n\\t\\t\\t\\\"        len=l;\\\",\\r\\n\\t\\t\\t\\\"        while(!a[len]) len--;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void print()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=std::max(len,1);i;i--) std::cout<<a[i];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline high_accuracy operator+(high_accuracy rhs)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        high_accuracy ret;\\\",\\r\\n\\t\\t\\t\\\"        int le=std::max(len,rhs.size());\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=le;i++) ret[i]+=a[i]+rhs[i],ret[i+1]=ret[i]/10,ret[i]%=10;\\\",\\r\\n\\t\\t\\t\\\"        ret.deal(le+2);\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline high_accuracy operator*(high_accuracy rhs)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        high_accuracy ret;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=len;i++) for(int j=1;j<=rhs.size();j++) ret[i+j-1]+=a[i]*rhs[j];\\\",\\r\\n\\t\\t\\t\\\"        ret.deal(len+rhs.size()+5);\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline high_accuracy operator-(high_accuracy rhs) // 适用于 *this 比 rhs 大的情况\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        high_accuracy ret;\\\",\\r\\n\\t\\t\\t\\\"        int le=std::max(len,rhs.size());\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=le+3;i++) ret[i]=0;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=le;i++) ret[i]+=a[i]-rhs[i];\\\",\\r\\n\\t\\t\\t\\\"        ret.deal(le+2);\\\",\\r\\n\\t\\t\\t\\\"        return ret;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline friend high_accuracy max(high_accuracy a,high_accuracy b)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        if(a.size()>b.size()) return a;\\\",\\r\\n\\t\\t\\t\\\"        if(a.size()<b.size()) return b;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=a.size();i;i--)\\\",\\r\\n\\t\\t\\t\\\"            if(a[i]>b[i]) return a;\\\",\\r\\n\\t\\t\\t\\\"            else if(a[i]<b[i]) return b;\\\",\\r\\n\\t\\t\\t\\\"        return a;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"AC_auto\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"AC_auto\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"class AC_auto\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"private:\\\",\\r\\n\\t\\t\\t\\\"    #define LEN 1000001\\\",\\r\\n\\t\\t\\t\\\"    #define N 200\\\",\\r\\n\\t\\t\\t\\\"    int a[LEN][26],val[LEN],flag[LEN],fail[LEN],ind[LEN],cnt,tmp;\\\",\\r\\n\\t\\t\\t\\\"    int ans[N],map[N];\\\",\\r\\n\\t\\t\\t\\\"    std::deque<int> q;\\\",\\r\\n\\t\\t\\t\\\"public:\\\",\\r\\n\\t\\t\\t\\\"    inline AC_auto()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        memset(fail,0,sizeof(fail)),memset(val,0,sizeof(val)),memset(flag,0,sizeof(flag));\\\",\\r\\n\\t\\t\\t\\\"        memset(a,0,sizeof(a)),memset(ind,0,sizeof(ind));\\\",\\r\\n\\t\\t\\t\\\"        memset(ans,0,sizeof(ans)),memset(map,0,sizeof(map));\\\",\\r\\n\\t\\t\\t\\\"        cnt=1;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void build()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=0;i<26;i++) a[0][i]=1;\\\",\\r\\n\\t\\t\\t\\\"        q.push_back(1);\\\",\\r\\n\\t\\t\\t\\\"        while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            tmp=q.front();q.pop_front();\\\",\\r\\n\\t\\t\\t\\\"            for(int i=0;i<26;i++)\\\",\\r\\n\\t\\t\\t\\\"                if(a[tmp][i])\\\",\\r\\n\\t\\t\\t\\\"                    fail[a[tmp][i]]=a[fail[tmp]][i],ind[fail[a[tmp][i]]]++,q.push_back(a[tmp][i]);\\\",\\r\\n\\t\\t\\t\\\"            else a[tmp][i]=a[fail[tmp]][i];\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void add(std::string st,int pos)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        int now=1;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=0;i<st.size();i++)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            if(!a[now][st[i]-'a']) a[now][st[i]-'a']=++cnt;\\\",\\r\\n\\t\\t\\t\\\"            now=a[now][st[i]-'a'];\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"        if(!flag[now]) flag[now]=pos;\\\",\\r\\n\\t\\t\\t\\\"        map[pos]=flag[now];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void ask(std::string st)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        int now=1;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=0;i<st.size();i++) now=a[now][st[i]-'a'],val[now]++;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void topo_sort()\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=1;i<=cnt;i++) if(!ind[i]) q.push_back(i);\\\",\\r\\n\\t\\t\\t\\\"        while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            tmp=q.front(),q.pop_front();\\\",\\r\\n\\t\\t\\t\\\"            ans[flag[tmp]]=val[tmp],val[fail[tmp]]+=val[tmp];\\\",\\r\\n\\t\\t\\t\\\"            if(!(--ind[fail[tmp]])) q.push_back(fail[tmp]);\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline void output(const int l,const int r)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        for(int i=l;i<=r;i++) out<<ans[map[i]]<<'\\\\\\\\n';\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\"\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"dinic\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"dinic\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n\\t\\t\\t\\\"struct edge\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    int to,f;\\\",\\r\\n\\t\\t\\t\\\"    edge *next,*oppo;\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"edge *head[N],*p[N];\\\",\\r\\n\\t\\t\\t\\\"inline void add(const int x,const int y,const int z)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    edge *e1=new edge,*e2=new edge;\\\",\\r\\n\\t\\t\\t\\\"    e1->to=y,e1->next=head[x],e1->f=z,e1->oppo=e2,head[x]=e1;\\\",\\r\\n\\t\\t\\t\\\"    e2->to=x,e2->next=head[y],e2->f=0,e2->oppo=e1,head[y]=e2;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"inline bool bfs() // ,s,t,pos,dis[N]\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    std::deque<int> q;\\\",\\r\\n\\t\\t\\t\\\"    memset(dis,0x3f,sizeof(dis)),q.clear(),q.push_back(s),dis[s]=0,p[s]=head[s];\\\",\\r\\n\\t\\t\\t\\\"    while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        pos=q.front(),q.pop_front();\\\",\\r\\n\\t\\t\\t\\\"        for(edge *i=head[pos];i!=nullptr;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"            if(i->f>0 && dis[i->to]==0x3f3f3f3f)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                q.push_back(i->to),dis[i->to]=dis[pos]+1,p[i->to]=head[i->to];\\\",\\r\\n\\t\\t\\t\\\"                if(i->to==t) return 1;\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    return 0;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"inline int dfs(int pos,int sum)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    if(pos==t) return sum;\\\",\\r\\n\\t\\t\\t\\\"    int ret=0,mini;\\\",\\r\\n\\t\\t\\t\\\"    for(edge *i=p[pos];i!=nullptr;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        p[pos]=i;\\\",\\r\\n\\t\\t\\t\\\"        if(i->f>0 && dis[i->to]==dis[pos]+1)\\\",\\r\\n\\t\\t\\t\\\"        {\\\",\\r\\n\\t\\t\\t\\\"            mini=dfs(i->to,std::min(sum,i->f));\\\",\\r\\n\\t\\t\\t\\\"            if(mini==0) dis[i->to]=0x3f3f3f3f;\\\",\\r\\n\\t\\t\\t\\\"            i->f-=mini,i->oppo->f+=mini,ret+=mini,sum-=mini;\\\",\\r\\n\\t\\t\\t\\\"            if(!sum) return ret;\\\",\\r\\n\\t\\t\\t\\\"        }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    return ret;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"mcmf\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"mcmf\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const int N=;\\\",\\r\\n\\t\\t\\t\\\"\\\",\\r\\n\\t\\t\\t\\\"struct edge\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    int to,f,c;\\\",\\r\\n\\t\\t\\t\\\"    edge *next,*oppo;\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"edge *head[N];\\\",\\r\\n\\t\\t\\t\\\"inline void add(const int x,const int y,const int z,const int c)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    edge *e1=new edge,*e2=new edge;\\\",\\r\\n\\t\\t\\t\\\"    e1->to=y,e1->next=head[x],e1->f=z,e1->c=c,e1->oppo=e2,head[x]=e1;\\\",\\r\\n\\t\\t\\t\\\"    e2->to=x,e2->next=head[y],e2->f=0,e2->c=-c,e2->oppo=e1,head[y]=e2;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"std::pair<int,edge *> p[N];\\\",\\r\\n\\t\\t\\t\\\"inline void spfa() // ,s,t,h[N],dis[N],vis[N],pos,mf,mc,mini\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    std::deque<int> q;\\\",\\r\\n\\t\\t\\t\\\"    memset(h,0x3f,sizeof(h)),h[s]=0,vis[s]=1,q.push_back(s);\\\",\\r\\n\\t\\t\\t\\\"    while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        pos=q.front(),q.pop_front(),vis[pos]=0;\\\",\\r\\n\\t\\t\\t\\\"        for(edge *i=head[pos];i!=nullptr;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"            if(i->f && h[i->to]>h[pos]+i->c)\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                h[i->to]=h[pos]+i->c;\\\",\\r\\n\\t\\t\\t\\\"                if(!vis[i->to]) vis[i->to]=1,q.push_back(i->to);\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t\\t\\\"inline bool dijkstra()\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    std::priority_queue< std::pair<int,int> > q;\\\",\\r\\n\\t\\t\\t\\\"    memset(dis,0x3f,sizeof(dis)),memset(vis,0,sizeof(vis)),dis[s]=0,q.push(std::make_pair(0,s));\\\",\\r\\n\\t\\t\\t\\\"    while(!q.empty())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        pos=q.top().second,q.pop();\\\",\\r\\n\\t\\t\\t\\\"        if(vis[pos]) continue;\\\",\\r\\n\\t\\t\\t\\\"        vis[pos]=1;\\\",\\r\\n\\t\\t\\t\\\"        for(edge *i=head[pos];i!=nullptr;i=i->next)\\\",\\r\\n\\t\\t\\t\\\"            if(i->f && dis[i->to]>dis[pos]+i->c+h[pos]-h[i->to])\\\",\\r\\n\\t\\t\\t\\\"            {\\\",\\r\\n\\t\\t\\t\\\"                dis[i->to]=dis[pos]+i->c+h[pos]-h[i->to],p[i->to]=std::make_pair(pos,i);\\\",\\r\\n\\t\\t\\t\\\"                if(!vis[i->to]) q.push(std::make_pair(-dis[i->to],i->to));\\\",\\r\\n\\t\\t\\t\\\"            }\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    return dis[t]!=0x3f3f3f3f;\\\",\\r\\n            \\\"}\\\",\\r\\n\\t\\t\\t\\\"inline void mcmf()\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    spfa();\\\",\\r\\n\\t\\t\\t\\\"    while(dijkstra())\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        mini=0x3f3f3f3f;\\\",\\r\\n\\t\\t\\t\\\"        for(int i=0;i<=t;i++) h[i]+=dis[i];\\\",\\r\\n\\t\\t\\t\\\"        for(int i=t;i!=s;i=p[i].first) mini=std::min(mini,p[i].second->f);\\\",\\r\\n\\t\\t\\t\\\"        for(int i=t;i!=s;i=p[i].first) p[i].second->f-=mini,p[i].second->oppo->f+=mini;\\\",\\r\\n\\t\\t\\t\\\"        mf+=mini,mc+=mini*h[t];\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"C\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"C\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"inline int C(int n,int m)\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    if(n<m || m<0 || n<0) return 0;\\\",\\r\\n\\t\\t\\t\\\"    return fac[n]*inv[m]%p*inv[n-m]%p;\\\",\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\t\\t]\\r\\n\\t},\\r\\n\\t\\\"geo\\\":\\r\\n\\t{\\r\\n\\t\\t\\\"prefix\\\": \\\"geo\\\",\\r\\n\\t\\t\\\"body\\\":\\r\\n\\t\\t[\\r\\n\\t\\t\\t\\\"const double eps=1e-8,pi=acos(-1);\\\",\\r\\n\\t\\t\\t\\\"struct point\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    double x,y;\\\",\\r\\n\\t\\t\\t\\\"    point(){x=y=0x3f3f3f3f;}\\\",\\r\\n\\t\\t\\t\\\"    point(double x,double y){this->x=x,this->y=y;}\\\",\\r\\n\\t\\t\\t\\\"    inline point operator-(const point &rhs) const{return point(x-rhs.x,y-rhs.y);}\\\",\\r\\n\\t\\t\\t\\\"    inline double operator*(const point &rhs) const{return x*rhs.y-y*rhs.x;}\\\",\\r\\n\\t\\t\\t\\\"    inline bool operator==(const point &rhs) const{return fabs(x-rhs.x)<=eps && fabs(y-rhs.y)<=eps;}\\\",\\r\\n\\t\\t\\t\\\"    inline friend double dis(const point lhs,const point rhs)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return sqrt((lhs.x-rhs.x)*(lhs.x-rhs.x)+(lhs.y-rhs.y)*(lhs.y-rhs.y));\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline friend int calc(const point x,const point y,const point z) // 三角形面积\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return abs((y-x)*(z-x));\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\",\\r\\n\\t\\t\\t\\\"inline int sgn(double x){return (fabs(x)<eps)?0:(x>0?1:-1);}\\\",\\r\\n\\t\\t\\t\\\"struct seg\\\",\\r\\n\\t\\t\\t\\\"{\\\",\\r\\n\\t\\t\\t\\\"    point s,t;\\\",\\r\\n\\t\\t\\t\\\"    inline seg(){}\\\",\\r\\n\\t\\t\\t\\\"    inline seg(point s,point t){this->s=s,this->t=t;}\\\",\\r\\n\\t\\t\\t\\\"    inline friend bool cross_straight(const seg &lhs,const seg &rhs) // 第一个参数传直线，第二个参数传线段\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return sgn((rhs.s-lhs.s)*(lhs.t-lhs.s))*sgn((rhs.t-lhs.s)*(lhs.t-lhs.s))<0;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline friend bool cross_seg(const seg &lhs,const seg &rhs)\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        return std::max(lhs.s.x,lhs.t.x)>=std::min(rhs.s.x,rhs.t.x) && \\\",\\r\\n\\t\\t\\t\\\"        std::max(lhs.s.y,lhs.t.y)>=std::min(rhs.s.y,rhs.t.y) && \\\",\\r\\n\\t\\t\\t\\\"        std::max(rhs.s.x,rhs.t.x)>=std::min(lhs.s.x,lhs.t.x) && \\\",\\r\\n\\t\\t\\t\\\"        std::max(rhs.s.y,rhs.t.y)>=std::min(lhs.s.y,lhs.t.y) && \\\",\\r\\n\\t\\t\\t\\\"        sgn((rhs.s-lhs.s)*(lhs.t-lhs.s))*sgn((rhs.t-lhs.s)*(lhs.t-lhs.s))<0 && \\\",\\r\\n\\t\\t\\t\\\"        sgn((lhs.s-rhs.s)*(rhs.t-rhs.s))*sgn((lhs.t-rhs.s)*(rhs.t-rhs.s))<0;\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"    inline friend point calc(const seg &lhs,const seg &rhs) // 计算两直线交点\\\",\\r\\n\\t\\t\\t\\\"    {\\\",\\r\\n\\t\\t\\t\\\"        double ix,iy,rat;\\\",\\r\\n\\t\\t\\t\\\"        rat=(rhs.t-lhs.s)*(rhs.s-lhs.s)/((rhs.t-lhs.s)*(rhs.s-lhs.s)-(rhs.t-lhs.t)*(rhs.s-lhs.t));\\\",\\r\\n\\t\\t\\t\\\"        ix=lhs.s.x+(lhs.t.x-lhs.s.x)*rat,iy=lhs.s.y+(lhs.t.y-lhs.s.y)*rat;\\\",\\r\\n\\t\\t\\t\\\"        return point(ix,iy);\\\",\\r\\n\\t\\t\\t\\\"    }\\\",\\r\\n\\t\\t\\t\\\"};\\\"\\r\\n\\t\\t]\\r\\n\\t},\\r\\n}\"}}","extensions":"[{\"identifier\":{\"id\":\"bierner.markdown-mermaid\",\"uuid\":\"f8d0ffc4-66bb-4a9c-8149-ef8f043691a1\"},\"displayName\":\"Markdown Preview Mermaid Support\"},{\"identifier\":{\"id\":\"davidanson.vscode-markdownlint\",\"uuid\":\"daf8b44d-8aae-4da2-80c5-1f770219f643\"},\"displayName\":\"markdownlint\"},{\"identifier\":{\"id\":\"divyanshuagrawal.competitive-programming-helper\",\"uuid\":\"28579c42-9973-4b79-9a1e-76431ea4bc1f\"},\"displayName\":\"Competitive Programming Helper (cph)\"},{\"identifier\":{\"id\":\"formulahendry.code-runner\",\"uuid\":\"a6a0c5b2-d078-4bf5-a9ee-4e37054414b3\"},\"displayName\":\"Code Runner\"},{\"identifier\":{\"id\":\"jeff-hykin.better-cpp-syntax\",\"uuid\":\"73767f91-7dcb-43cb-90b3-596d073eea1f\"},\"displayName\":\"Better C++ Syntax\"},{\"identifier\":{\"id\":\"ms-ceintl.vscode-language-pack-zh-hans\",\"uuid\":\"e4ee7751-6514-4731-9cdb-7580ffa9e70b\"},\"displayName\":\"Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code\"},{\"identifier\":{\"id\":\"ms-vscode.cmake-tools\",\"uuid\":\"7c889349-8749-43d4-8b5e-08939936d7f4\"},\"displayName\":\"CMake Tools\"},{\"identifier\":{\"id\":\"ms-vscode.cpptools\",\"uuid\":\"690b692e-e8a9-493f-b802-8089d50ac1b2\"},\"displayName\":\"C/C++\"},{\"identifier\":{\"id\":\"ms-vscode.cpptools-extension-pack\",\"uuid\":\"3957b2f6-f086-49b5-a7b4-5da772123130\"},\"displayName\":\"C/C++ Extension Pack\"},{\"identifier\":{\"id\":\"ms-vscode.cpptools-themes\",\"uuid\":\"99b17261-8f6e-45f0-9ad5-a69c6f509a4f\"},\"displayName\":\"C/C++ Themes\"},{\"identifier\":{\"id\":\"phantom.gcc-md\",\"uuid\":\"9c271b79-0458-42d2-87fa-793e5b532a46\"},\"displayName\":\"GCC Machine Description\"},{\"identifier\":{\"id\":\"shd101wyy.markdown-preview-enhanced\",\"uuid\":\"3b1db1fc-c7f7-4bd6-9fa4-b499dfa99a8a\"},\"displayName\":\"Markdown Preview Enhanced\",\"disabled\":true},{\"identifier\":{\"id\":\"twxs.cmake\",\"uuid\":\"2be7cf14-2603-402e-9771-fd79df83cdf8\"},\"displayName\":\"CMake\"},{\"identifier\":{\"id\":\"yzhang.markdown-all-in-one\",\"uuid\":\"98790d67-10fa-497c-9113-f6c7489207b2\"},\"displayName\":\"Markdown All in One\"}]"}